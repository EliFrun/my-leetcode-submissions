class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial.sort()
        edges = []
        for i in range(len(graph)):
            for j in range(i + 1, len(graph[0])):
                if i == j:
                    continue
                if graph[i][j] == 0:
                    continue
                edges.append((i, j))

        graphs = []
        for p, c in edges:
            p_idx, c_idx = -1, -1
            for i, g in enumerate(graphs):
                if p in g:
                    p_idx = i
                if c in g:
                    c_idx = i

            if p_idx == c_idx:
                if p_idx >= 0:
                    continue
                else:
                    graphs.append(set([p, c]))
            else:
                if p_idx == -1:
                    graphs[c_idx].add(p)
                elif c_idx == -1:
                    graphs[p_idx].add(c)
                else:
                    g1, g2 = graphs.pop(max(p_idx, c_idx)), graphs.pop(min(p_idx, c_idx))
                    graphs.append(g1 | g2)

        infected_nodes_in_cc = [0] * len(graph)
        belongs_to = [-1] * len(initial)
        for j, init in enumerate(initial):
            for i, g in enumerate(graphs):
                if init in g:
                    infected_nodes_in_cc[i] += 1
                    belongs_to[j] = i
                    break

        if not graphs:
            return initial[0]
        
        ret = initial[0]
        count = -1
        for i, init in enumerate(initial):
            if belongs_to[i] == -1:
                if count < 1:
                    ret = init
                    count = 1
                continue

            if infected_nodes_in_cc[belongs_to[i]] > 1:
                continue
            if len(graphs[belongs_to[i]]) > count:
                count = len(graphs[belongs_to[i]])
                ret = init

        #print(graphs)
        #print(infected_nodes_in_cc)
        #print(belongs_to)

        return ret

            

        


